var documenterSearchIndex = {"docs":
[{"location":"objects/#AnnData-and-MuData","page":"AnnData and MuData","title":"AnnData and MuData","text":"","category":"section"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"To put it briefly, AnnData objects represent annotated datasets with the main data as a matrix and with rich annotations that might include tables and arrays. MuData objects represent collections of AnnData objects focusing on, but not limited to, scenarios with different AnnData objects representing different sets of features profiled for the same samples.","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"Originally, both AnnData objects and MuData objects have been implemented in Python.","category":"page"},{"location":"objects/#AnnData","page":"AnnData and MuData","title":"AnnData","text":"","category":"section"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"AnnData implementation in Muon.jl tries to mainly follow the reference implementation, albeit there are some differences in how these objects are implemented and behave due to how different languages are designed and opeate.","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"AnnData objects can be stored in and read from .h5ad files.","category":"page"},{"location":"objects/#Creating-AnnData-objects","page":"AnnData and MuData","title":"Creating AnnData objects","text":"","category":"section"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"A simple 2D array is already enough to initialize an annotated data object:","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"import Random # hide\nRandom.seed!(1) # hide\nimport Muon.AnnData # hide\nx = rand(10, 2) * rand(2, 5);\nad = AnnData(X=x)","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"Observations correpond to the rows of the matrix and have unique names:","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"ad.obs_names .= \"obs_\" .* ad.obs_names","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"Corresponding arrays for the observations are stored in the .obsm slot:","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"import LinearAlgebra.svd, LinearAlgebra.Diagonal # hide\nf = svd(x);\nad.obsm[\"X_svd\"] = f.U * Diagonal(f.S);","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"When data is assigned, it is verified first that the dimensions match:","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"ad.obsm[\"X_Vt\"] = f.Vt  # won't work\n# => DimensionMismatch","category":"page"},{"location":"objects/#Slicing-AnnData-objects","page":"AnnData and MuData","title":"Slicing AnnData objects","text":"","category":"section"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"Just as simple arrays, AnnData objects can be subsetted with slicing operations, with the first dimension corresponding to observations and the second dimension corresponding to variables:","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"obs_sub = \"obs_\" .* string.(collect(1:3))\nad_sub = ad[obs_sub,:]","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"Since the dimensions are labelled, using names is a natural way to subset these objects but boolean and integer arrays can be used as well:","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"# both return the same subset\nad_sub[[true,false,true],:]\nad_sub[[1,3],:]","category":"page"},{"location":"objects/#Operations-on-AnnData-Objects","page":"AnnData and MuData","title":"Operations on AnnData Objects","text":"","category":"section"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"Make duplicate var_names unique by appending a numbered suffix.","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"import Muon: var_names_make_unique! # hide\nvar_names_make_unique!(ad)","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"Similarly, we can make obs_names unique also.","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"import Muon: obs_names_make_unique! # hide\nobs_names_make_unique!(ad)","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"The data matrices of AnnData objects can be converted to a DataFrame, annotated with obs and var names.","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"using DataFrames\nDataFrame(ad)","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"By default, the first column obs corresponds to the obs_names and the remaining columns are named according to the var_names. To obtain the transpose of this, pass columns=:obs.","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"To use a different data matrix (the default is ad.X), pass the name of the layer:","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"DataFrame(ad, layer=\"raw\")","category":"page"},{"location":"objects/#MuData","page":"AnnData and MuData","title":"MuData","text":"","category":"section"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"The basic idea behind a multimodal object is key rightarrow value relationship where keys represent the unique names of individual modalities and values are AnnData objects that contain the correposnding data. Similarly to AnnData objects, MuData objects can also contain rich multimodal annotations.","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"import Distributions.Binomial # hide\nimport Muon.MuData # hide\nad2 = AnnData(X=rand(Binomial(1, 0.3), (10, 7)),\n              obs_names=\"obs_\" .* string.(collect(1:10)))\n\nmd = MuData(mod=Dict(\"view_rand\" => ad, \"view_binom\" => ad2))","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"Features are considered unique to each modality.","category":"page"},{"location":"objects/#Slicing-MuData-objects","page":"AnnData and MuData","title":"Slicing MuData objects","text":"","category":"section"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"Slicing now works across all modalities:","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"md[[\"obs_1\", \"obs_9\"],:]","category":"page"},{"location":"objects/#Multimodal-annotation","page":"AnnData and MuData","title":"Multimodal annotation","text":"","category":"section"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"We can store annotation at the multimodal level, that includes multidimensional arrays:","category":"page"},{"location":"objects/","page":"AnnData and MuData","title":"AnnData and MuData","text":"md.obsm[\"X_svd\"] = f.U * Diagonal(f.S);\nmd.obsm","category":"page"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api/types/#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"api/types/#All-types","page":"Types","title":"All types","text":"","category":"section"},{"location":"api/types/#Muon.AnnData","page":"Types","title":"Muon.AnnData","text":"An annotated data object that stores data matrices with associated metadata.\n\nConstructor\n\nAnnData(;\n    X::AbstractMatrix{<:Number},\n    obs::Union{DataFrame, Nothing}=nothing,\n    obs_names::Union{AbstractVector{<:AbstractString}, Nothing}=nothing,\n    var::Union{DataFrame, Nothing}=nothing,\n    var_names::Union{AbstractVector{<:AbstractString}, Nothing}=nothing,\n    obsm::Union{AbstractDict{<:AbstractString, <:Union{<:AbstractArray{<:Number}, DataFrame}}, Nothing}=nothing,\n    varm::Union{AbstractDict{<:AbstractString, <:Union{<:AbstractArray{<:Number}, DataFrame}}, Nothing}=nothing,\n    obsp::Union{AbstractDict{<:AbstractString, <:AbstractMatrix{<:Number}}, Nothing}=nothing,\n    varp::Union{AbstractDict{<:AbstractString, <:AbstractMatrix{<:Number}}, Nothing}=nothing,\n    layers::Union{AbstractDict{<:AbstractString, <:AbstractMatrix{<:Number}}, Nothing}=nothing,\n    uns::Union{AbstractDict{<:AbstractString, <:Any}, Nothing}=nothing,\n)\n\nKeyword arguments / fields of the object\n\nX: An observations × variables matrix.\nobs: A DataFrame with observation-level metadata.\nobs_names: A vector of observation names (identifiers).\nvar: A DataFrame with variable-level metadata.\nvar_names: A vector of ariable names (identifiers).\nobsm: Dictionary with observation-level metadata.\nvarm: Dictionary of observation-level metadata.\nobsp: Dictionary of pairwise observation-level metadata. Each element of obsp is a square matrix.\nvarp: Dictionary of pairwise variable-level metadata. Each element of varp is a square matrix.\nlayers: Dictionary of additional observations × variables matrices, e.g. for different processing/normalization steps.\nuns: Dictionary with unstructured metadata.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Muon.MuData","page":"Types","title":"Muon.MuData","text":"A multimodal data object that stores collections of AnnData objects.\n\nConstructor\n\nMuData(;\n    mod::Union{AbstractDict{<:AbstractString, AnnData}, Nothing}=nothing,\n    obs::Union{DataFrame, Nothing}=nothing,\n    obs_names::Union{AbstractVector{<:AbstractString}, Nothing}=nothing,\n    var::Union{DataFrame, Nothing}=nothing,\n    var_names::Union{AbstractVector{<:AbstractString}, Nothing}=nothing,\n    obsm::Union{AbstractDict{<:AbstractString, <:Union{<:AbstractArray{<:Number}, DataFrame}}, Nothing}=nothing,\n    varm::Union{AbstractDict{<:AbstractString, <:Union{<:AbstractArray{<:Number}, DataFrame}}, Nothing}=nothing,\n    obsp::Union{AbstractDict{<:AbstractString, <:AbstractMatrix{<:Number}}, Nothing}=nothing,\n    varp::Union{AbstractDict{<:AbstractString, <:AbstractMatrix{<:Number}}, Nothing}=nothing,\n    obsmap::Union{AbstractDict{<:AbstractString, <:AbstractVector{<:Integer}}, Nothing}=nothing,\n    varmap::Union{AbstractDict{<:AbstractString, <:AbstractVector{<:Integer}}, Nothing}=nothing,\n    uns::Union{AbstractDict{<:AbstractString, <:Any}, Nothing}=nothing,\n    axis::Union{Integer, Nothing}=nothing,\n)\n\nKeyword arguments / fields of the object\n\nmod: A dictionary of AnnData objects.\nobs: A DataFrame with observation-level metadata.\nobs_names: A vector of observation names (identifiers). The names correspond to obs_names of the AnnData objects.\nvar: A DataFrame with variable-level metadata\nvar_names: A vector of variable names (identifiers). The names correspond to var_names of the AnnData objects.\nobsm: Dictionary of observation-level metadata.\nvarm: Dictionary of variable-level metadata.\nobsp: Dictionary of pairwise observation-level metadata. Each element of obsp is a square matrix.\nvarp: Dictionary of pairwise variable-level metadata. Each element of varp is a square matrix.\nobsmap: Dictionary with one integer vector for each modality. The vectors contain for each observation in the MuData object the index of corresponding observation in the respective AnnData object, or 0 if the observation is not present. This argument to the constructor should generally not be required unless you know what you're doing.\nvarmap: Dictionary with one integer vector for each modality. The vectors contain for each variable in the MuData object the index of the corresponding variable in the respective AnnData object, or 0 if the observation is not present. This argument to the constructor should generally not be required unless you know what you're doing.\nuns: Dictionary with unstructured metadata.\naxis: Axis of the object. axis=1 (default) indicates sharing of observations, each AnnData object is treated as a separate modality with no overlapping variables. axis=2 indicates sharing of variables, each AnnData is treated as a dataset with no overlapping observations. axis=0 indicates sharing of both observations and variables, useful when the different AnnData objects are subsets of the same dataset.\n\n\n\n\n\n","category":"type"},{"location":"#Muon.jl:-multimodal-framework","page":"Muon.jl: multimodal framework","title":"Muon.jl: multimodal framework","text":"","category":"section"},{"location":"","page":"Muon.jl: multimodal framework","title":"Muon.jl: multimodal framework","text":"Muon.jl provides functionality to work with multimodal datasets in Julia. It implements annotated data structures for unimodal and multimodal data and can be used together with the muon ecosystem across programming languages with data exchange via .h5mu files.","category":"page"},{"location":"","page":"Muon.jl: multimodal framework","title":"Muon.jl: multimodal framework","text":"Muon.jl is part of the scverse® project (website, governance) and is fiscally sponsored by NumFOCUS. If you like scverse® and want to support our mission, please consider making a tax-deductible donation to help the project pay for developer time, professional services, travel, workshops, and a variety of other needs.","category":"page"},{"location":"","page":"Muon.jl: multimodal framework","title":"Muon.jl: multimodal framework","text":"<div align=\"center\">\n<a href=\"https://numfocus.org/project/scverse\">\n  <img\n    src=\"https://raw.githubusercontent.com/numfocus/templates/master/images/numfocus-logo.png\"\n    width=\"200\"\n  >\n</a>\n</div>","category":"page"},{"location":"io/#I/O","page":"I/O","title":"I/O","text":"","category":"section"},{"location":"io/#Reading-.h5mu-files","page":"I/O","title":"Reading .h5mu files","text":"","category":"section"},{"location":"io/","page":"I/O","title":"I/O","text":"To read multimodal HDF5 files, which have the .h5mu extension, there is readh5mu:","category":"page"},{"location":"io/","page":"I/O","title":"I/O","text":"m = readh5mu(\"multimodal_dataset.h5mu\")\n# => MuData object 10101 x 101010","category":"page"},{"location":"io/#Writing-.h5mu-files","page":"I/O","title":"Writing .h5mu files","text":"","category":"section"},{"location":"io/","page":"I/O","title":"I/O","text":"To save the multimodal object on disk, there is writeh5mu:","category":"page"},{"location":"io/","page":"I/O","title":"I/O","text":"writeh5mu(\"multimodal_dataset.h5mu\", m)","category":"page"},{"location":"io/#io_anndata","page":"I/O","title":".h5ad files I/O","text":"","category":"section"},{"location":"io/","page":"I/O","title":"I/O","text":"For serializing and deserializing AnnData objects, there are writeh5ad and readh5ad:","category":"page"},{"location":"io/","page":"I/O","title":"I/O","text":"writeh5ad(\"dataset.h5ad\", ad)\nad = readh5ad(\"dataset.h5ad\")","category":"page"},{"location":"api/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"api/functions/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"api/functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"api/functions/#All-functions","page":"Functions","title":"All functions","text":"","category":"section"},{"location":"api/functions/#Base.getindex","page":"Functions","title":"Base.getindex","text":"getindex(\n    data::Union{AbstractAnnData, AbstractMuData},\n    I::Union{OrdinalRange, Colon, AbstractVector{<:Integer}, AbstractVector{<:AbstractString}, Number, AbstractString},\n    J::Union{OrdinalRange, Colon, AbstractVector{<:Integer}, AbstractVector{<:AbstractString}, Number, AbstractString},\n)\n\nSubset data to observations I and variables J.\n\nIndexing can be performed by numerical index or by name, where names are looked up in data.obs_names and data.var_names.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Base.getindex-Tuple{Muon.AbstractMuData, Symbol}","page":"Functions","title":"Base.getindex","text":"getindex(mdata::AbstractMuData, modality::Union{AbstractString, Symbol})::AnnData\n\nGet a modality from mdata.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Base.setindex!-Tuple{MuData, AnnData, AbstractString}","page":"Functions","title":"Base.setindex!","text":"setindex!(mdata::AbstractMuData, ad::AnnData, key::Union{AbstractString, Symbol})\n\nInsert or overwrite a modality in mdata.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Base.size","page":"Functions","title":"Base.size","text":"size(data::Union{AbstractAnnData, AbstractMuData}, [dim::Integer])\n\nReturn a tuple containing the number of observations and variables of adata. Optionally you can specify a dimension to get just the length of that dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Base.view","page":"Functions","title":"Base.view","text":"view(data::Union{AbstractAnnData, AbstractMuData},\n    I::Union{OrdinalRange, Colon, AbstractVector{<:Integer}, AbstractVector{<:AbstractString}, Number, AbstractString},\n    J::Union{OrdinalRange, Colon, AbstractVector{<:Integer}, AbstractVector{<:AbstractString}, Number, AbstractString},\n)\n\nLike getindex, but returns a lightweight object that lazily references the parent object.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Base.write","page":"Functions","title":"Base.write","text":"write(data::Union{AbstractAnnData, AbstractMuData}; compress::UInt8=0x9)\nwrite(parent::Union{HDF5.File, HDF5.Group, ZGroup}, data::Union{AbstractAnnData, AbstractMuData}; compress::UInt8=0x9)\n\nWrite the data to disk.\n\nThe first form writes the metadata of a backed AnnData or MuData object to disk. The second form writes the data to an already open HDF5 or Zarr file into the group parent.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Base.write-Tuple{Union{HDF5.File, HDF5.Group}, AbstractString, Muon.AbstractAnnData}","page":"Functions","title":"Base.write","text":"write(parent::Union{HDF5.File, HDF5.Group, ZGroup}, name::AbstractString, adata::AbstractAnnData; compress::UInt8=0x9)\n\nWrite the adata to an already open HDF5 or Zarr file into the group parent as a subgroup with name name.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.isbacked-Tuple{Union{Muon.AbstractAnnData, Muon.AbstractMuData}}","page":"Functions","title":"Muon.isbacked","text":"isbacked(ad::Union{AbstractMuData, AbstractAnnData})::Bool\n\nReturn true if ad is backed on disk, and false otherwise.\n\nSee also readh5ad, readzarrad, readh5mu, readzarrmu.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.obs_names_make_unique!","page":"Functions","title":"Muon.obs_names_make_unique!","text":"obs_names_make_unique!(mdata::MuData, join='-')\n\nCall obs_names_make_unique! for each modality.\n\nIf there are obs_names which are the same for multiple modalities, the modality name is prepended to al obs_names.\n\nSee also var_names_make_unique!(::MuData), obs_names_make_unique!(::AnnData), var_names_make_unique!(::AnnData)\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Muon.obs_names_make_unique!-2","page":"Functions","title":"Muon.obs_names_make_unique!","text":"obs_names_make_unique!(ad::AnnData, join='-')\n\nMake ad.obs_names unique by appending join and sequential numbers (1, 2, 3 etc) to duplicate elements, leaving the first unchanged.\n\nSee also var_names_make_unique!(::AnnData).\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Muon.pull_obs!-Union{Tuple{MuData}, Tuple{M}, Tuple{N}} where {N, M}","page":"Functions","title":"Muon.pull_obs!","text":"pull_obs!(\n    mdata::MuData;\n    columns::Union{AbstractVector{<:AbstractString}, NTuple{N, <:AbstractString}, AbstractString, Nothing}=nothing,\n    mods::Union{AbstractVector{<:AbstractString}, NTuple{M, <:AbstractString}, AbstractString, Nothing}=nothing,\n    common::Union{Bool, Nothing}=nothing,\n    join_common::Union{Bool, Nothing}=nothing,\n    nonunique::Union{Bool, Nothing}=nothing,\n    join_nonunique::Bool=false,\n    unique::Union{Bool, Nothing}=nothing,\n    prefix_unique::Bool=true,\n    drop::Bool=false,\n    only_drop::Bool=false,\n) where {N, M}\n\nCopy metadata from the .obs of the individual modalities to the global .obs of the MuData object, overwriting or updating existing columns.\n\nArguments\n\nmdata: The MuData object.\ncolumns: Columns to pull from the modalities. Pulls everything by default.\nmods: Modalities to pull from. Pull from all modalities by default.\ncommon: Whether to pull common columns. Common columns exist in all modalities. Cannot be used together with columns. Defaults to true.\njoin_common: Whether to join common columns. Joined columns do not have a modality prefix. Defaults to true if mdata.axis == 0x1 (shared .obs), false otherwise.\nnonunique: Whether to pull nonunique columns. Non-unique columns exist in at least two, but not all modalities. Cannot be used together with columns. Defaults to true.\njoin_nonunique: Whether to join non-unique columns. Joined columns do not have a modality prefix.\nunique: Whether to pull unique columns. Unique columns exist in exactly one modality. Cannot be used together with columns. Defaults to true.\nprefix_unique: Whether to prefix unique columns with the modality name.\ndrop: Whether to delete columns from the modalities after pulling.\nonly_drop: Whether to only delete the columns from the modalities, but not actually pull them. Implies drop=true.\n\nSee also pull_var!, push_obs!, push_var!.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.pull_var!-Union{Tuple{MuData}, Tuple{M}, Tuple{N}} where {N, M}","page":"Functions","title":"Muon.pull_var!","text":"pull_var!(\n    mdata::MuData;\n    columns::Union{AbstractVector{<:AbstractString}, NTuple{N, <:AbstractString}, AbstractString, Nothing}=nothing,\n    mods::Union{AbstractVector{<:AbstractString}, NTuple{M, <:AbstractString}, AbstractString, Nothing}=nothing,\n    common::Union{Bool, Nothing}=nothing,\n    join_common::Union{Bool, Nothing}=nothing,\n    nonunique::Union{Bool, Nothing}=nothing,\n    join_nonunique::Bool=false,\n    unique::Union{Bool, Nothing}=nothing,\n    prefix_unique::Bool=true,\n    drop::Bool=false,\n    only_drop::Bool=false,\n) where {N, M}\n\nCopy metadata from the .var of the individual modalities to the global .var of the MuData object, overwriting or updating existing columns.\n\nArguments\n\nmdata: The MuData object.\ncolumns: Columns to pull from the modalities. Pulls everything by default.\nmods: Modalities to pull from. Pull from all modalities by default.\ncommon: Whether to pull common columns. Common columns exist in all modalities. Cannot be used together with columns. Defaults to true.\njoin_common: Whether to join common columns. Joined columns do not have a modality prefix. Defaults to true if mdata.axis == 0x1 (shared .obs), false otherwise.\nnonunique: Whether to pull nonunique columns. Non-unique columns exist in at least two, but not all modalities. Cannot be used together with columns. Defaults to true.\njoin_nonunique: Whether to join non-unique columns. Joined columns do not have a modality prefix.\nunique: Whether to pull unique columns. Unique columns exist in exactly one modality. Cannot be used together with columns. Defaults to true.\nprefix_unique: Whether to prefix unique columns with the modality name.\ndrop: Whether to delete columns from the modalities after pulling.\nonly_drop: Whether to only delete the columns from the modalities, but not actually pull them. Implies drop=true.\n\nSee also pull_obs!, push_obs!, push_var!.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.push_obs!-Union{Tuple{MuData}, Tuple{M}, Tuple{N}} where {N, M}","page":"Functions","title":"Muon.push_obs!","text":"push_obs!(\n    mdata::MuData;\n    columns::Union{AbstractVector{<:AbstractString}, NTuple{N, <:AbstractString}, AbstractString, Nothing}=nothing,\n    mods::Union{AbstractVector{<:AbstractString}, NTuple{M, <:AbstractString}, AbstractString, Nothing}=nothing,\n    common::Union{Bool, Nothing}=nothing,\n    prefixed::Union{Bool, Nothing}=nothing,\n    drop::Bool=false,\n    only_drop::Bool=false,\n) where {N, M}\n\nCopy metadata from mdata.obs to the .obs of the individual modalities, overwriting existing columns.\n\nArguments\n\nmdata: The MuData object.\ncolumns: Columns to push. Pushes everything by default.\nmods: Modalities to push to. Pushes to all modalities by default.\ncommon: Whether to push common columns. Common columns do not have modality prefixes. Cannot be used together with columns. Defaults to true.\nprefixed: Whether to push columns with a modality prefix. Only push to the respective modalities. Cannot be used together with columns. Defaults to true.\ndrop: Whether to delete columns from mdata.obs after pushing.\nonly_drop: Whether to only delete the columns from mdata.obs, but not actually push them. Implies drop=true.\n\nSee also push_var!, pull_obs!, pull_var!.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.push_var!-Union{Tuple{MuData}, Tuple{M}, Tuple{N}} where {N, M}","page":"Functions","title":"Muon.push_var!","text":"push_var!(\n    mdata::MuData;\n    columns::Union{AbstractVector{<:AbstractString}, NTuple{N, <:AbstractString}, AbstractString, Nothing}=nothing,\n    mods::Union{AbstractVector{<:AbstractString}, NTuple{M, <:AbstractString}, AbstractString, Nothing}=nothing,\n    common::Union{Bool, Nothing}=nothing,\n    prefixed::Union{Bool, Nothing}=nothing,\n    drop::Bool=false,\n    only_drop::Bool=false,\n) where {N, M}\n\nCopy metadata from mdata.var to the .var of the individual modalities, overwriting existing columns.\n\nArguments\n\nmdata: The MuData object.\ncolumns: Columns to push. Pushes everything by default.\nmods: Modalities to push to. Pushes to all modalities by default.\ncommon: Whether to push common columns. Common columns do not have modality prefixes. Cannot be used together with columns. Defaults to true.\nprefixed: Whether to push columns with a modality prefix. Only push to the respective modalities. Cannot be used together with columns. Defaults to true.\ndrop: Whether to delete columns from mdata.obs after pushing.\nonly_drop: Whether to only delete the columns from mdata.obs, but not actually push them. Implies drop=true.\n\nSee also push_obs!, pull_obs!, pull_var!.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.readh5ad-Tuple{AbstractString}","page":"Functions","title":"Muon.readh5ad","text":"readh5ad(filename::AbstractString; backed=false)::AnnData\n\nRead an AnnData object stored in an h5ad file.\n\nIn backed mode, matrices X and layers are not read into memory, but are instead represented by proxy objects reading the required matrix elements from disk upon access.\n\nSee also readzarrad, writeh5ad, writezarrad, isbacked.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.readh5mu-Tuple{AbstractString}","page":"Functions","title":"Muon.readh5mu","text":"readh5mu(filename::AbstractString; backed=false)::MuData\n\nRead a MuData object stored in an h5mu file.\n\nIn backed mode, matrices X and layers for each modality are not read into memory, but are instead represented by proxy objects reading the required matrix elements from disk upon access.\n\nSee also readzarrmu, writeh5mu, writezarrmu, isbacked.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.readzarrad-Tuple{AbstractString}","page":"Functions","title":"Muon.readzarrad","text":"readzarrad(filename::AbstractString; backed=false)::AnnData\n\nRead an AnnData object stored in a Zarr file.\n\nIn backed mode, matrices X and layers are not read into memory, but are instead represented by proxy objects reading the required matrix elements from disk upon access.\n\nSee also readh5ad, writeh5ad, writezarrad, isbacked.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.readzarrmu-Tuple{AbstractString}","page":"Functions","title":"Muon.readzarrmu","text":"readzarr(filename::AbstractString; backed=false)::MuData\n\nRead a MuData object stored in a Zarr file.\n\nIn backed mode, matrices X and layers for each modality are not read into memory, but are instead represented by proxy objects reading the required matrix elements from disk upon access.\n\nSee also readh5mu, writeh5mu, writezarrmu, isbacked.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.update!-Tuple{MuData}","page":"Functions","title":"Muon.update!","text":"update!(mdata::MuData)\n\nUpdate the MuData object with information from all modalities.\n\nThis function should be called after adding or removing modalities. It will update the MuData's obs_names and var_names as well as the obsmap and `varmap.\n\nSee also update_obs!, update_var!.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.update_obs!-Tuple{MuData}","page":"Functions","title":"Muon.update_obs!","text":"update_obs!(mdata::MuData)\n\nUpdate the MuData's obs_names and obsmap with information from all modalities.\n\nSee also update_var!, update!.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.update_var!-Tuple{MuData}","page":"Functions","title":"Muon.update_var!","text":"update_var!(mdata::MuData)\n\nUpdate the MuData's var_names and varmap with information from all modalities.\n\nSee also update_obs!, update!.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.var_names_make_unique!","page":"Functions","title":"Muon.var_names_make_unique!","text":"var_names_make_unique!(mdata::MuData, join='-')\n\nCall var_names_make_unique! for each modality.\n\nIf there are var_names which are the same for multiple modalities, the modality name is prepended to al var_names.\n\nSee also obs_names_make_unique!(::MuData), obs_names_make_unique!(::AnnData), var_names_make_unique!(::AnnData)\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Muon.var_names_make_unique!-2","page":"Functions","title":"Muon.var_names_make_unique!","text":"var_names_make_unique!(ad::AnnData, join='-')\n\nMake ad.var_names unique by appending join and sequential numbers (1, 2, 3 etc) to duplicate elements, leaving the first unchanged.\n\nSee also obs_names_make_unique!(::AnnData).\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Muon.writeh5ad-Tuple{AbstractString, Muon.AbstractAnnData}","page":"Functions","title":"Muon.writeh5ad","text":"writeh5ad(filename::AbstractString, adata::AbstractAnnData; compress::UInt8=0x9)\n\nWrite an AnnData object to disk using the h5ad format (HDF5 with a particular structure).\n\ncompress indicates the level of compression to apply, from 0 (no compression) to 9 (highest compression).\n\nSee also writezarrad, readh5ad, readzarrad.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.writeh5mu-Tuple{AbstractString, Muon.AbstractMuData}","page":"Functions","title":"Muon.writeh5mu","text":"writeh5mu(filename::AbstractString, mudata::AbstractMuData; compress::UInt8=0x9)\n\nWrite a MuData object to disk using the h5mu format (HDF5 with a particular structure).\n\ncompress indicates the level of compression to apply, from 0 (no compression) to 9 (highest compression).\n\nSee also writezarrmu, readh5mu, readzarrmu.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.writezarrad-Tuple{AbstractString, Muon.AbstractAnnData}","page":"Functions","title":"Muon.writezarrad","text":"writezarrad(filename::AbstractString, adata::AbstractAnnData; compress::UInt8=0x9)\n\nWrite an AnnData object to disk using the Zarr format.\n\ncompress indicates the level of compression to apply, from 0 (no compression) to 9 (highest compression).\n\nSee also writeh5ad, readh5ad, readzarrad.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Muon.writezarrmu-Tuple{AbstractString, Muon.AbstractMuData}","page":"Functions","title":"Muon.writezarrmu","text":"writezarrmu(filename::AbstractString, mudata::AbstractMuData; compress::UInt8=0x9)\n\nWrite a MuData object to disk using the Zarr format.\n\ncompress indicates the level of compression to apply, from 0 (no compression) to 9 (highest compression).\n\nSee also writeh5mu, readh5mu, readzarrmu.\n\n\n\n\n\n","category":"method"}]
}
